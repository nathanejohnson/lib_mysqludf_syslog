/*
 * Syslog libary for MySQL.
 * Copyright (C) [Nathan Johnson <nathan@nathanjohnson.info>]

Function is called as:
syslog_write(facility, priority, ident, log_message)

where facility is one of:
     'LOG_AUTH'      The authorization system: login(1), su(1), getty(8), etc.
     'LOG_AUTHPRIV'  The same as LOG_AUTH, but logged to a file readable only by selected individuals.
     'LOG_USER'      Messages generated by random user processes. This is the default facility identifier if none is specified.
     'LOG_DAEMON'    system daemons without separate facility value
     'LOG_LOCAL0'-'LOG_LOCAL7'    Reserved for local use.  Similarly for LOG_LOCAL1 through LOG_LOCAL7.

and priority is one of:
      LOG_EMERG   system is unusable
      LOG_ALERT    action must be taken immediately
      LOG_CRIT	     critical conditions
      LOG_ERR	     error conditions
      LOG_WARNING warning conditions
      LOG_NOTICE  normal, but significant, condition
      LOG_INFO	   informational message
      LOG_DEBUG    debug-level message

ident is prepended to every message, and is typically set to the application name
message is what is meant to be sent to syslog

to compile (on linux, for example):
gcc `mysql_config --cflags` -fPIC -shared -o lib_mysqludf_syslog.so lib_mysqludf_syslog.c

NOTE: most likely this will never compile on Windows, though it is vaguely possible that it could interface with syslog installed via cygwin.

to create function:

create function lib_mysqludf_syslog_info returns string soname 'lib_mysqludf_syslog.so';
create function syslog_write returns integer soname 'lib_mysqludf_syslog.so';

after copying syslog_udf.so to the appropriate place (plugin dir), or setting LD_LIBRARY_PATH as per the documentation


 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at
 * your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
 * General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#define LIBVERSION "lib_mysqludf_syslog version 0.0.1"


#if defined(_WIN32) || defined(_WIN64) || defined(__WIN32__) || defined(WIN32)
#define DLLEXP __declspec(dllexport)
#else
#define DLLEXP
#endif



#include <syslog.h>
#include <mysql.h>
#include <stdlib.h>
#include <string.h>



/* These must be right or mysqld will not find the symbol! */
DLLEXP my_bool lib_mysqludf_syslog_info_init(UDF_INIT *initid, UDF_ARGS *args, char *message);
DLLEXP void lib_mysqludf_syslog_info_deinit(UDF_INIT *initid);
DLLEXP char *lib_mysqludf_syslog_info(UDF_INIT *initid, UDF_ARGS *args, char *result, unsigned long *length, char *is_null, char *error);
DLLEXP my_bool syslog_write_init(UDF_INIT *initid, UDF_ARGS *args, char *message);
DLLEXP void syslog_write_deinit(UDF_INIT *initid);
DLLEXP long long syslog_write(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error);
DLLEXP int decode_facility(char *facility_txt, unsigned long length);
DLLEXP int decode_priority(char *priority_txt, unsigned long length);


typedef struct  {
  int facility;
  int priority;
  char * message;
  char * identity;
} syslog_udf_data;


/*
 * Output the library version.
 * lib_mysqludf_syslog_info()
 */

my_bool lib_mysqludf_syslog_info_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
	return 0;
}

void lib_mysqludf_syslog_info_deinit(UDF_INIT *initid)
{
}

char* lib_mysqludf_syslog_info(UDF_INIT *initid, UDF_ARGS *args, char* result, unsigned long* length,	char *is_null, char *error)
{
	strcpy(result, LIBVERSION);
	*length = strlen(LIBVERSION);
	return result;
}






/* Definitions */

my_bool syslog_write_init(UDF_INIT *initid, UDF_ARGS *args, char *message) {
  int facility;
  int priority;
  syslog_udf_data *sud = NULL;
  initid->maybe_null=0;

  if (args->arg_count != 4) {
    strcpy(message, "usage: syslog_write(facility, priority, identity, message)");
    return 1;
  }
  if (args->arg_type[0] != STRING_RESULT) {
    strcpy(message, "facility should be a string");
    return 1;
  }
  if (args->arg_type[1] != STRING_RESULT) {
    strcpy(message, "priority should be a string");
    return 1;
  }
  if (args->arg_type[2] != STRING_RESULT) {
    strcpy(message, "identity should be a string");
    return 1;
  }
  if (args->arg_type[3] != STRING_RESULT) {
    strcpy(message, "message should be a string");
    return 1;
  }
  if ((facility = decode_facility(args->args[0], args->lengths[0])) == -1) {
    strcpy(message, "facility not recognized");
    return 1;
  }
  if ((priority = decode_priority(args->args[1], args->lengths[1])) == -1) {
    strcpy(message, "priority not recognized");
    return 1;
  }

  /* copy data into syslog_udf_data structure */
  if((  sud = (syslog_udf_data *) malloc(sizeof(syslog_udf_data))) == NULL) {
    strcpy(message, "memory error allocating system_udf_data struct");
    return 1;
  }
  sud->facility=facility;
  sud->priority=priority;
  /* copy identity and message into internal null terminated buffers */
  if ((sud->message = (char *) malloc((args->lengths[3]+1) * sizeof(char))) == NULL) {
    strcpy(message, "memory allocation error for message buff");
    free(sud);
    return 1;
  }
  else {
    memcpy(sud->message, args->args[3], args->lengths[3]);
    sud->message[args->lengths[3]] = '\0';
  }
  if ((sud->identity= (char *) malloc((args->lengths[2]+1) * sizeof(char))) == NULL) {
    strcpy(message, "memory allocation error for identity buff");
    free(sud->message);
    free(sud);
    return 1;
  }
  else {
    memcpy(sud->identity, args->args[2], args->lengths[2]);
    sud->identity[args->lengths[2]] = '\0';
  }
  initid->ptr = (char *) sud;
  return 0;
}
void syslog_write_deinit(UDF_INIT *initid) {
  syslog_udf_data *sud = (syslog_udf_data *) initid->ptr;
  if (sud) {
    if (sud->message) {
      free(sud->message);
    }
    if (sud->identity) {
      free(sud->identity);
    }
    free(sud);
  }
}

long long syslog_write(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error) {
  syslog_udf_data *sud = (syslog_udf_data *)initid->ptr;
  openlog((const char *)sud->identity, LOG_ODELAY, sud->facility);
  syslog(sud->priority,"%s",sud->message);
  closelog();
  *is_null = 0;
  *error = 0;
  return 0;
}

int decode_facility(char *facility_txt, unsigned long length) {
  char *fac_trim = NULL;
  size_t trim_length = length - 4;
  if (strncmp(facility_txt, "LOG_", 4) == 0) {
    fac_trim = &(facility_txt[4]);
    if (strncmp(fac_trim, "AUTH", trim_length) == 0) {
      return LOG_AUTH;
    }
    else if (strncmp(fac_trim, "AUTHPRIV", trim_length) == 0) {
      return LOG_AUTHPRIV;
    }
    else if (strncmp(fac_trim, "USER", trim_length) == 0) {
      return LOG_USER;
    }
    else if (strncmp(fac_trim, "DAEMON", trim_length) == 0) {
      return LOG_DAEMON;
    }
    else if (strncmp(fac_trim, "LOCAL0", trim_length) == 0) {
      return LOG_LOCAL0;
    }
    else if (strncmp(fac_trim, "LOCAL1", trim_length) == 0) {
      return LOG_LOCAL1;
    }
    else if (strncmp(fac_trim, "LOCAL2", trim_length) == 0) {
      return LOG_LOCAL2;
    }
    else if (strncmp(fac_trim, "LOCAL3", trim_length) == 0) {
      return LOG_LOCAL3;
    }
    else if (strncmp(fac_trim, "LOCAL4", trim_length) == 0) {
      return LOG_LOCAL4;
    }
    else if (strncmp(fac_trim, "LOCAL5", trim_length) == 0) {
      return LOG_LOCAL5;
    }
    else if (strncmp(fac_trim, "LOCAL6", trim_length) == 0) {
      return LOG_LOCAL6;
    }
    else if (strncmp(fac_trim, "LOCAL7", trim_length) == 0) {
      return LOG_LOCAL7;
    }
  }
  return -1;
}
int decode_priority(char *priority_txt, unsigned long length) {
  char *prio_trim = NULL;
  size_t trim_length = length - 4;
  if (strncmp(priority_txt, "LOG_", 4) == 0) {
    prio_trim = &(priority_txt[4]);
    if (strncmp(prio_trim, "EMERG", trim_length) == 0) {
      return LOG_EMERG;
    }
    else if (strncmp(prio_trim, "ALERT", trim_length) == 0) {
      return LOG_ALERT;
    }
    else if (strncmp(prio_trim, "CRIT", trim_length) == 0) {
      return LOG_CRIT;
    }
    else if (strncmp(prio_trim, "ERR", trim_length) == 0) {
      return LOG_ERR;
    }
    else if (strncmp(prio_trim, "WARNING", trim_length) ==0) {
      return LOG_WARNING;
    }
    else if (strncmp(prio_trim, "NOTICE", trim_length) ==0) {
      return LOG_NOTICE;
    }
    else if (strncmp(prio_trim, "INFO", trim_length) ==0) {
      return LOG_INFO;
    }
    else if (strncmp(prio_trim, "DEBUG", trim_length) ==0) {
      return LOG_DEBUG;
    }
  }
  return -1;
}
